import { DepositedFile, Item, Schema } from './';
import { References } from './references';
import { Tristate, isTristate } from './tristate';
import { Uuid } from './uuid';
import { assert } from '../assert';
import { VocabularyEntry as MbdbVocabularyEntry, isVocabularyEntry } from '../mbdb/vocabulary';

type BaseValue = {
    __mbdb_value: true,
};

function mkValue<T>(payload: T, isValid = false) {
    return { __mbdb_value: true as true, payload, isValid };
};

export type CalendarDate = {
    year: number,
    month: number,
    day: number,
};

export type DepositedFilePayload = {
    __mbdb_stored_file: '__mbdb_stored_file',
} & DepositedFile;
function DepositedFilePayload(file: File | null, metadata: string): DepositedFilePayload {
    return {
        __mbdb_stored_file: '__mbdb_stored_file',
        file,
        metadata,
    };
}

export type Option = {
    tag: string,
    other?: string,
};

export type VocabularyEntry = {
    id: string,
    title: string,
    data: MbdbVocabularyEntry | null,
};

export type Value = BaseValue & {
    payload: boolean | string | CalendarDate | Option | Tristate | DepositedFilePayload | VocabularyEntry
    isValid: boolean,
};
export type TValue<T extends Value['payload']> = BaseValue & {
    payload: T,
    isValid: boolean,
};

export const Value = {
    autogeneratedForItem(item: Item): TValue<string> {
        if (Schema.hasUuidInput(item)) {
            return this.uuid();
        } else if (Schema.hasReferenceableIdInput(item)) {
            return this.refId();
        } else if (Schema.hasInternalIdInput(item)) {
            return this.uuid(); // The value can be any random string but let's keep things fancy
        }

        assert(false,`Attempted to get autogenerated value for item "${item.tag}" that does not have automatically generated input`);
    },

    boolean(tf: boolean): TValue<boolean> {
        return mkValue(tf, true);
    },

    calendarDate(year: number, month: number, day: number, isValid = true): TValue<CalendarDate> {
        return mkValue({ year, month, day }, isValid);
    },

    defaultForItem(item: Item, isRequiredOverride: boolean | undefined = void 0) {
        const isRequired = isRequiredOverride !== undefined ? isRequiredOverride : item.isRequired;

        if (Schema.hasBooleanInput(item)) {
            return this.tristate('not-set', !item.isRequired);
        } else if (Schema.hasCalendarDateInput(item)) {
            const now = new Date();
            return this.calendarDate(now.getFullYear(), now.getMonth() + 1, now.getDate());
        } else if (Schema.hasTextualInput(item)) {
            return this.empty(!isRequired);
        } else if (Schema.hasOptionsInput(item)) {
            return Schema.initialOptionsValue(isRequired);
        } else if (Schema.hasUrlInput(item)) {
            return Value.empty(!isRequired);
        } else if (Schema.hasVocabularyInput(item)) {
            return this.emptyVocabularyEntry(!isRequired);
        } else if (Schema.hasFileInput(item)) {
            return this.emptyFile(!isRequired);
        }

        assert(false, `Attempted to get default value for item "${item.tag}" with input "${item.input}" but no default value is available`);
    },

    empty(isValid = false) {
        const v = mkValue('');
        v.isValid = isValid;

        return v;
    },

    emptyFile(isValid = false) {
        const v = mkValue(DepositedFilePayload(null, ''));
        v.isValid = isValid;

        return v;
    },

    emptyOption(isValid = true) {
        const v = this.option(Schema.EmptyChoice);
        v.isValid = isValid;

        return v;
    },

    emptyVocabularyEntry(isValid: boolean) {
        return this.vocabularyEntry('', '', null, isValid);
    },

    file(file: File | null, metadata: string, isValid: boolean): TValue<DepositedFilePayload> {
        const v = mkValue(DepositedFilePayload(file, metadata));
        v.isValid = isValid;

        return v;
    },

    isBoolean(value: Value): value is TValue<boolean> {
        return typeof value.payload === 'boolean';
    },

    isCalendarDate(value: Value): value is TValue<CalendarDate> {
        if (typeof value.payload !== 'object') {
            return false;
        }

        const date = value.payload as Record<string, any>;
        if (typeof date !== 'object' || date['year'] === undefined || date['month'] === undefined || date['day'] === undefined) {
            return false;
        }

        return typeof date.year === 'number' && typeof date.month === 'number' && typeof date.day === 'number';
    },

    isEmpty(value: Value) {
        if (typeof value.payload === 'string') {
            return value.payload === '';
        } else if (this.isOption(value)) {
            return this.isEmptyOption(value);
        } else if (this.isFile(value)) {
            return this.isEmptyFile(value);
        } else if (this.isVocabularyEntry(value)) {
            return this.isEmptyVocabularyEntry(value);
        } else {
            return false;
        }
    },

    isEmptyFile(value: TValue<DepositedFilePayload>) {
        return value.payload.file === null;
    },

    isEmptyOption(value: TValue<Option>) {
        return value.payload.tag === Schema.EmptyChoice;
    },

    isEmptyVocabularyEntry(value: TValue<VocabularyEntry>) {
        const p = value.payload;

        return p.data === null && p.id === '' && p.title === '';
    },

    isOption(value: Value): value is TValue<Option> {
        if (typeof value.payload !== 'object') {
            return false;
        }

        const opt = value.payload as Record<string, any>;
        return opt['tag'] !== undefined && (opt['other'] !== undefined ? typeof opt['other'] === 'string' : true);
    },

    isRefId(value: Value): value is TValue<string> {
        if (typeof value.payload !== 'string') {
            return false;
        } else {
            return References.isValidRefId(value.payload);
        }
    },

    isRelToId(value: Value): value is TValue<string> {
        if (typeof value.payload !== 'string') {
            return false;
        } else {
            return value.payload === '' || References.isValidRefId(value.payload);
        }
    },

    isFile(value: Value): value is TValue<DepositedFilePayload> {
        const p = value.payload as any;
        return p['__mbdb_stored_file'] === '__mbdb_stored_file';
    },

    isTextual(value: Value): value is TValue<string> {
        return typeof value.payload === 'string';
    },

    isTristate(value: Value): value is TValue<Tristate> {
        return isTristate(value.payload);
    },

    isUuid(value: Value): value is TValue<string> {
        return typeof value.payload === 'string' && Uuid.check(value.payload);
    },

    isValid(value: Value) {
        return value.isValid;
    },

    isValidDiscriminator(value: TValue<'string'>, choices: string[]) {
        return choices.includes(value.payload);
    },

    isValue(obj?: Record<string, any>): obj is Value {
        if (obj === undefined) return false;
        return (
            obj['__mbdb_value'] === true &&
            obj['payload'] !== undefined &&
            typeof obj['isValid'] === 'boolean'
        );
    },

    isVocabularyEntry(value: Value): value is TValue<VocabularyEntry> {
        if (typeof value.payload !== 'object') return false;

        const p = value.payload as any;
        return (
            typeof p['id'] === 'string' &&
            (p['data'] === null || isVocabularyEntry(p['data']))
        );
    },

    option(tag: string, other?: string) {
        return mkValue({ tag, other }, true);
    },

    refId(v?: string): TValue<string> {
        if (!v) {
            return mkValue(Uuid.get(), true);
        } else {
            if (!References.isValidRefId(v)) {
                throw new Error(`Attempted to set referenceable ID to a value "${v}" that is not a valid UUIDv4.`);
            }
            return mkValue(v, true);
        }
    },

    toBoolean(value: Value) {
        if (!this.isBoolean(value)) {
            throw new Error(`Value with payload ${value.payload} is not a boolean.`);
        }

        return value.payload;
    },

    toCalendarDate(value: Value) {
        if (!this.isCalendarDate(value)) {
            throw new Error(`Value with payload ${value.payload} is not a calendar date.`);
        }

        return value.payload;
    },

    toFile(value: Value) {
        if (!this.isFile(value)) {
            throw new Error(`Value with paylado ${value.payload} is not a File.`);
        }

        return value.payload;
    },

    toOtherOption(value: Value) {
        if (!this.isOption(value)) {
            throw new Error(`Value with payload ${value.payload} is not an Option.`);
        }
        if (typeof value.payload.other !== 'string') {
            throw new Error(`Value with payload ${value.payload} is not an Option with other choice`);
        }

        return value.payload.other;
    },

    toOption(value: Value) {
        if (!this.isOption(value)) {
            throw new Error(`Value with payload ${value.payload} is not an Option.`);
        }

        return value.payload.tag;
    },

    toRefId(value: Value) {
        if (!this.isRefId(value)) {
            throw new Error(`Value with payload ${value.payload} is not a referenceable ID`);
        }

        return value.payload;
    },

    toRelToId(value: Value) {
        if (!this.isRelToId(value)) {
            throw new Error(`Value with payload ${value.payload} is not a related-to ID`);
        }

        return value.payload;
    },

    toTextual(value: Value) {
        if (!this.isTextual(value)) {
            throw new Error(`Value with payload ${value.payload} is not a string`);
        }

        return value.payload;
    },

    toTristate(value: Value) {
        if (!this.isTristate(value)) {
            throw new Error(`Value with payload ${value.payload} is not a tristate value`);
        }

        return value.payload;
    },

    toVocabularyEntry(value: Value) {
        if (!this.isVocabularyEntry(value)) {
            throw new Error(`Value with payload ${value.payload} is not a vocabulary entry value`);
        }

        return value.payload;
    },

    textual(text: string, isValid: boolean): TValue<string> {
        return mkValue<string>(text, isValid);
    },

    tristate(tfn: Tristate, isValid: boolean) {
        assert(isTristate(tfn), `Value ${tfn} is not a valid tristate value`);

        return mkValue(tfn, isValid);
    },

    uuid(v?: string): TValue<string> {
        if (!v) {
            return mkValue(Uuid.get(), true);
        } else {
            if (!Uuid.check(v)) {
                throw new Error(`Attempted to set referenceable ID to a value "${v}" that is not a valid UUIDv4.`);
            }
            return mkValue(v, true);
        }
    },

    vocabularyEntry(id: string, title: string, data: VocabularyEntry['data'], isValid: boolean) {
        return mkValue<VocabularyEntry>({ id, title, data }, isValid);
    },
};
