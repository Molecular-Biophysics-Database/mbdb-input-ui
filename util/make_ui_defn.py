#! /usr/bin/env python3

from argparse import ArgumentParser
from pathlib import Path
import pprint
import re
import traceback
from typing import Dict, Union
import uuid
import yaml

MBDBModel = Dict[str, Union[str, Dict]]
HelpFieldRegex = re.compile('^(\\^)?help.([a-z]){2}$')
JSVarNameRegex = re.compile('^([A-Za-z_]){1}([A-Za-z0-9_])*$')

# MEGAHAKZ MEGAHAKZ MEGAHAKZ
# Hardcoded list of items that are supposed to be autogenerated but the schema
# does not indicate that
AUTOGENERATED_ITEM_NAMES = [
    'internal_id',
    'identifier',
    'measurement_group_id',
]

CUSTOM_COMPONENTS = {
    'Value_error': 'value-error',
}

PAD = ' ' * 4


class UIGParamsError(Exception):
    pass


class UIGSchemaError(Exception):
    pass


class TypeDefnArg:
    def __init__(self, name):
        self.name = name
        self.args = []

    def __str__(self):
        return f'Name: "{self.name}", args: "{self.args}"'


pp = pprint.PrettyPrinter(indent=2, compact=False)


def _mk_parser():
    parser = ArgumentParser(
        description='MBDB UI Generator. A tool to generate a UI definition schema from a OARepo database schema file.'
    )
    parser.add_argument(
        '--input',
        type=Path,
        required=True,
        help='Input OARepo schema file.'
    )
    parser.add_argument(
        '--output',
        type=Path,
        required=False,
        help='Name of the output file. Output is written to stdout if no output file is provided.'
    )
    parser.add_argument(
        '--schema_name',
        type=str,
        required=False,
        help='Name of the schema. Used to generate more specific output.'
    )

    return parser


def _warn(msg):
    print('WARNING: {}'.format(msg))


def append_path(tail, prefix):
    return prefix + ('/' if prefix else '') + tail


def closing_string_index(s: str):
    N = len(s)

    idx = 0
    while idx < N:
        ch = s[idx]
        if ch == "'":
            return idx

        idx += 1

    raise UIGSchemaError(f'Unterminated string in string "{s}"')


def get_custom_component(path):
    c = CUSTOM_COMPONENTS

    for tok in path:
        if tok in c:
            c = c[tok]
        else:
            return None

    return c


def get_item_from_defs(id, defs):
    idx = id.rfind('/');
    item_path = id[idx + 1:].split('/');

    custom = get_custom_component(item_path)
    if custom:
        return (custom, True)

    item = defs
    while item_path:
        p = item_path.pop(0)
        if p not in defs:
            raise UIGParamsError(f'Requested definition on path "{id}" but no such definition exists')
        item = item[p]

    return (item, False)


def get_help_fields(item):
    help_fields = []

    if not isinstance(item, dict):
        _warn(f'Item "{item}" is not a dictionary. I will ignore it but you definitely want to check the input file and fix the issue there.')
        return []

    for key in item.keys():
        if HelpFieldRegex.match(key):
            help_fields.append(key)

    return help_fields


def item_defn(item, defs, name, mbdbPath):
    defn = {}
    help_fields = get_help_fields(item)

    if 'properties' in item:
        defn['input'] = ui_defn(item['properties'], defs, mbdbPath)
    elif 'use' in item:
        inner_item, is_custom = get_item_from_defs(item['use'], defs)
        if is_custom:
            defn['input'] = 'custom'
            defn['component'] = inner_item
        else:
            if isinstance(inner_item, str):
                defn['input'] = inner_item
            else:
                defn = item_defn(inner_item, defs, name, mbdbPath)
    elif 'type' in item:
        t = item['type']
        if t == 'boolean':
            defn['input'] = 'boolean'
        elif t == 'integer':
            defn['input'] = 'int'
            if 'minimum' in item:
                defn['minimum'] = item['minimum']
            if 'maximum' in item:
                defn['maximum'] = item['maximum']
        elif t == 'double':
            defn['input'] = 'float'
            if 'minimum' in item:
                defn['minimum'] = item['minimum']
            if 'maximum' in item:
                defn['maximum'] = item['maximum']
        elif t == 'date':
            defn['input'] = 'calendar-date'
        elif t == 'keyword':
            if 'enum' in item:
                choices = [{ 'tag': x, 'title': x } for x in item['enum']]
                defn['input'] = 'options'
                defn['choices'] = choices
            # MEGAHAKZ MEGAHAKZ MEGAHAKZ - This section below needs to be reworked
            elif name in AUTOGENERATED_ITEM_NAMES:
                defn['input'] = 'uuid'
            elif name == 'version':
                defn['input'] = 'ignore' # Temporary HAKZ
            else:
                defn['input'] = 'string'
        elif t == 'polymorphic':
            if 'schemas' not in item:
                raise UIGSchemaError('Got a polymorphic type but no "schemas"')
            if 'discriminator' not in item:
                raise UIGSchemaError('Got a polymorphic type but no "discriminator"')

            discriminator = item['discriminator']

            variants = {}
            for name, schema in item['schemas'].items():
                ui = make_ui_item(name, schema, mbdbPath)
                inner_defn = item_defn(schema, defs, name, mbdbPath)

                if not mark_discriminator_item_as_discriminator(inner_defn, discriminator):
                    pp.pprint(inner_defn)
                    raise UIGSchemaError(f'Field "{discriminator}" is used as polymorphic type discriminator but it is not present in the polymorphic type')

                ui = { **ui, **inner_defn }
                variants[name] = ui

            defn['input'] = variants
            defn['discriminator'] = discriminator
        elif t == 'uuid':
            defn['input'] = 'uuid'
        elif t == 'relation':
            if 'model' not in item:
                raise UIGSchemaError(f'Field "{item.tag}" is a relation but does not say which item it relates to ("model" key is missing)')
            if 'keys' not in item:
                raise UIGSchemaError(f'Field "{item.tag}" is a relation but does not say which fields from the related item it is interested in ("keys" key is missing)')

            defn['input'] = 'related-to'
            defn['relatesTo'] = mbdb_relates_to(item['model'])
            defn['relatedKeys'] = mbdb_related_keys(item['keys']);
        elif t == 'vocabulary':
            if 'vocabulary-type' not in item:
                raise UIGSchemaError(f'Field "{item.tag}" is a vocabulary but it does not specify vocabulary-type')
            if 'keys' not in item:
                raise UIGSchemaError(f'Field "{item.tag}" is a vocabulary but it does not specify any keys')

            defn['input'] = 'vocabulary'
            defn['vocabularyType'] = item['vocabulary-type']
            defn['vocabularyKeys'] = item['keys']
        else:
            _warn(f'Type "{t}" is not handled, setting its input type to "ignore".')
            defn['input'] = 'ignore'
    else:
        _warn(f'I do not know how to handle item "{item}", setting its input type to "unknown".')
        defn['input'] = 'unknown'

    if 'id' in item:
        repurpose_id_as_referenceable_id(defn, item['id'])
    if help_fields:
        help = {}
        for hf in help_fields:
            lang = hf.split('.')[1]
            help[lang] = item[hf];

        defn['help'] = help

    # defn['internalId'] = uuid_for_item()

    return defn


def make_ui_item(name, props, mbdbPath):
    isArray = name.endswith('[]')

    item = {
        'tag': mbdb_tag(name),
        'label': mbdb_tag(name),
        'isArray': isArray,
        'isRequired': False,
        'mbdbPath': mbdbPath,
    }

    if isArray:
        if '^required' in props and props['^required'] == True:
            item['isRequired'] = True
        if '^minItems' in props:
            item['minItems'] = props['^minItems']
    else:
        if 'required' in props and props['required'] == True:
            item['isRequired'] = True

    return item


def mark_discriminator_item_as_discriminator(defn, discr):
    if isinstance(defn['input'], dict):
        for item in defn['input'].values():
            return mark_discriminator_item_as_discriminator(item, discr)
    elif isinstance(defn['input'], list):
        for item in defn['input']:
            if item['tag'] == discr:
                item['input'] = 'variant-discriminator'
                return True
    else:
        return defn['tag'] == discr

    return False


def mbdb_related_keys(keys):
    if not isinstance(keys, list):
        raise UIGSchemaError(f'Related keys must be a list, got {keys} instead')

    # TODO: We should check if the keys really exists in the item we are referencing
    return keys


def mbdb_relates_to(relation):
    idx = relation.find('#')
    if idx != 0:
        raise UIGSchemaError(f'Relation value "{relation}" must begin with "#"')

    rel = relation[1:]
    if len(rel) == 0:
        raise UIGSchemaError(f'Relation value "{relation} is empty')

    return rel


def mbdb_tag(name):
    return name[:-2] if name.endswith('[]') else name


def oarepo_definition_to_ui(input_file: Path):
    fh = open(input_file, 'r')
    model = yaml.safe_load(fh)
    fh.close()

    defs = model['$defs']
    if not defs:
        raise UIGSchemaError('Model does not contain "$defs"')

    top_level_defn = model['record']['properties']['metadata']['properties']
    if not top_level_defn:
        raise UIGSchemaError('Model does not define anything')

    return ui_defn(top_level_defn, defs, '')


def repurpose_id_as_referenceable_id(defn, reference_as):
    # HAKZ HAKZ HAKZ:
    # The model definition does not tell us anything useful here so we have to deploy some guesswork.
    # If an item is "referenceable", it means that other items in the model will refer to that item.
    # An item must be referenceable by some unique ID. That ID must be part of the data associated
    # with the item. The UI should generate such IDs automatically. But how can the UI know which
    # datum of the item is used as the referenceable ID if the model definition does not tell us?
    # Well, we will just assume that that a "keyword" type of item named "id" is the ID.

    if 'input' not in defn:
        pp.pprint(defn)
        raise UIGSchemaError('Item does not have "input" key')

    input = defn['input']

    if isinstance(input, dict):
        for inner_defn in input.values():
            repurpose_id_as_referenceable_id(inner_defn, reference_as)
    elif isinstance(input, list):
        did_fixup = False
        for inner_defn in input:
            if inner_defn['tag'] == 'id':
                if not isinstance(inner_defn['input'], str) or inner_defn['input'] != 'uuid':
                    raise UIGSchemaError('Attempted to repurpose the "id" inner item for referenceable ID but it has a wrong input type.')
                inner_defn['input'] = 'referenceable-id'
                inner_defn['referenceAs'] = reference_as
                did_fixup = True

        if not did_fixup:
            raise UIGSchemaError('Attempted to repurpose the "id" inner item for referenceable ID but no such inner item exists.')

    else:
        pp.pprint(defn)
        raise UIGSchemaError('Got a referenceable item that does not have complex input. I do not know what to do with that.')


def to_js(schema_name, ui):
    out = f'export const {schema_name} = '
    out += to_js_complex(ui, 0)
    out += ';\n'

    return out


def to_js_complex(input, indent):
    SPC = PAD * indent
    out = '[\n'

    for item in input:
        out += to_js_item(item, indent + 1) + ',\n'

    out += SPC + ']'

    return out


def to_js_input(input, indent):
    if isinstance(input, list):
        return to_js_complex(input, indent)
    elif isinstance(input, dict):
        return to_js_variant(input, indent)
    return f'\'{input}\''


def to_js_item(item, indent, no_lead_indent = False):
    SPC = PAD * indent
    out = ('' if no_lead_indent else SPC) + '{\n'

    for k, v in item.items():
        if k == 'input':
            out += SPC + PAD + 'input: {},\n'.format(to_js_input(v, indent + 1))
        else:
            out += SPC + PAD + '{}: {},\n'.format(to_js_key(k), to_js_value(v, indent + 1))

    out += SPC + '}'

    return out


def to_js_key(k):
    if ' ' in k:
        return "'" + k + "'"
    return k


def to_js_value(v, indent):
    if isinstance(v, str):
        v = v.replace("'", "\\'")
        return f'\'{v}\''
    elif isinstance(v, bool):
        return 'true' if v else 'false'
    elif isinstance(v, list):
        SPC = PAD * indent
        out = '[\n'
        for elem in v:
            if isinstance(elem, dict):
                out += to_js_item(elem, indent + 1) + ',\n'
            else:
                out += SPC + PAD + to_js_value(elem, indent + 1) + ',\n'
        out += SPC + ']'

        return out
    elif isinstance(v, dict):
        SPC = PAD * indent
        out = '{\n'
        for k, v in v.items():
            out += SPC + PAD + '{}: {},\n'.format(to_js_key(k), to_js_value(v, indent + 1))
        out += SPC + '}'

        return out
    else:
        return v


def to_js_variant(input, indent):
    SPC = PAD * indent
    out = '{\n'

    for k, v in input.items():
        out += SPC + PAD + '{}: {},\n'.format(to_js_key(k), to_js_item(v, indent + 1, True))

    out += SPC + '}'

    return out


def ui_defn(defn, defs, parentMbdbPath):
    ui = []
    for name, props in defn.items():
        mbdbPath = append_path(name, parentMbdbPath)
        item = make_ui_item(name, props, mbdbPath)
        input_defn = item_defn(props, defs, name, mbdbPath)
        item = { **item, **input_defn }

        ui.append(item)

    return ui


def uuid_for_item():
    return str(uuid.uuid4())


if __name__ == '__main__':
    parser = _mk_parser()
    args = parser.parse_args()

    try:
        input_file: Path = args.input
        if not input_file.is_file():
            raise UIGParamsError('Input file does not exist or it is not a file')

        schema_name = args.schema_name if args.schema_name else 'UI'
        if not JSVarNameRegex.match(schema_name):
            raise UIGParamsError(f'"schema_name" must be a valid JavaScript variable name but "{schema_name}" is not.')

        ui = oarepo_definition_to_ui(input_file)
        js = to_js(schema_name, ui)

        output_file = args.output
        if output_file:
            with open(output_file, 'w') as fh:
                fh.write(js)
        else:
            print(js)
    except UIGParamsError as ex:
        print(f'*** Invalid parameters: {ex}')
    except UIGSchemaError as ex:
        print(f'*** Cannot process the schema: {ex}')
        print(traceback.format_exc())
